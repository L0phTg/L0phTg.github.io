<!DOCTYPE html>
<html lang="">
<head>

  <meta charset="utf-8" />

  
  <title>elf文件格式和AndroidLinker加载.so的源码分析</title>

  
  
  
  <link href="//cdnjs.cloudflare.com" rel="dns-prefetch">
  
  <link href="//at.alicdn.com" rel="dns-prefetch">
  
  <link href="//fonts.googleapis.com" rel="dns-prefetch">
  <link href="//fonts.gstatic.com" rel="dns-prefetch">
  
  
  
  
  

  

  
  
  <meta name="description" content="最近在学习android应用的加壳和混淆方法, 所以遇到了一些有关.so是如何加载到android中去的问题, 看了一些视频和文章, 所以想在此总结一下.
本文主要内容:
elf的文件格式 分析linker的源码, 主要dlopen流程. ">

  
  
    <meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="@gohugoio">
    <meta name="twitter:title" content="elf文件格式和AndroidLinker加载.so的源码分析">
    <meta name="twitter:description" content="最近在学习android应用的加壳和混淆方法, 所以遇到了一些有关.so是如何加载到android中去的问题, 看了一些视频和文章, 所以想在此总结一下.
本文主要内容:
elf的文件格式 分析linker的源码, 主要dlopen流程. ">
    <meta name="twitter:image" content="/images/avatar.png">
  

  
  <meta property="og:type" content="article">
  <meta property="og:title" content="elf文件格式和AndroidLinker加载.so的源码分析">
  <meta property="og:description" content="最近在学习android应用的加壳和混淆方法, 所以遇到了一些有关.so是如何加载到android中去的问题, 看了一些视频和文章, 所以想在此总结一下.
本文主要内容:
elf的文件格式 分析linker的源码, 主要dlopen流程. ">
  <meta property="og:url" content="http://L0phTg.top/post/elf%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%92%8Candroidlinker%E5%8A%A0%E8%BD%BD-so%E7%9A%84%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">
  <meta property="og:image" content="/images/avatar.png">






<link rel="canonical" href="http://L0phTg.top/post/elf%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%92%8Candroidlinker%E5%8A%A0%E8%BD%BD-so%E7%9A%84%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">

<meta name="renderer" content="webkit">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="format-detection" content="telephone=no,email=no,adress=no">
<meta http-equiv="Cache-Control" content="no-transform">


<meta name="robots" content="index,follow">
<meta name="referrer" content="origin-when-cross-origin">







<meta name="theme-color" content="#02b875">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">
<meta name="apple-mobile-web-app-title" content="L0phTg&#39;s Blog">
<meta name="msapplication-tooltip" content="L0phTg&#39;s Blog">
<meta name='msapplication-navbutton-color' content="#02b875">
<meta name="msapplication-TileColor" content="#02b875">
<meta name="msapplication-TileImage" content="/icons/icon-144x144.png">
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/icons/icon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/icons/icon-32x32.png">
<link rel="icon" sizes="192x192" href="/icons/icon-192x192.png">
<link rel="apple-touch-icon" href="/icons/icon-152x152.png">
<link rel="manifest" href="/manifest.json">


<link rel="preload" href="/styles/main-rendered.min.css" as="style">


<link rel="preload" href="https://fonts.googleapis.com/css?family=Lobster" as="style">
<link rel="preload" href="/images/avatar.png" as="image">
<link rel="preload" href="/images/grey-prism.svg" as="image">


<style>
  body {
    background: rgb(244, 243, 241) url('/images/grey-prism.svg') repeat fixed;
  }
</style>
<link rel="stylesheet" href="/styles/main-rendered.min.css">


<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lobster">



<script src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.2/dist/medium-zoom.min.js"></script>




<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/video.js@7.3.0/dist/video-js.min.css">




<link rel="stylesheet" href="/css/styles/dracula.css">




  
  
<!--[if lte IE 8]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/videojs-ie8@1.1.2/dist/videojs-ie8.min.js"></script>
<![endif]-->

<!--[if lte IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/eligrey-classlist-js-polyfill@1.2.20180112/classList.min.js"></script>
<![endif]-->


  

  <script src="/js/highlight.pack.js"></script>


<script>hljs.initHighlightingOnLoad();</script>
<script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
<script> mermaid.initialize({ startOnLoad: true });</script>

</head>
  <body>
    <div class="suspension">
      <a role="button" aria-label="Go to top" title="Go to top" class="to-top is-hide"><span class="icon icon-up" aria-hidden="true"></span></a>
      
        
      
    </div>
    
    
    
  
  <header class="site-header">
  <a href="http://L0phTg.top/"><img class="avatar" src="/images/avatar.png" alt="Avatar"></a>
  
  <h2 class="title"><a href="http://L0phTg.top/">L0phTg&#39;s Blog</a></h2>
  
  <p class="subtitle">~  读万卷书 &amp; 行万里路 ~</p>
  <button class="menu-toggle" type="button" aria-label="Main Menu" aria-expanded="false" tab-index="0">
    <span class="icon icon-menu" aria-hidden="true"></span>
  </button>

  <nav class="site-menu collapsed">
    <h2 class="offscreen">Main Menu</h2>
    <ul class="menu-list">
      
      
      
      
        <li class="menu-item
          
          
           is-active">
          <a href="/">Home</a>
        </li>
      
        <li class="menu-item
          
          
          ">
          <a href="/post/">Archives</a>
        </li>
      
        <li class="menu-item
          
          
          ">
          <a href="/tags/">Tags</a>
        </li>
      
        <li class="menu-item
          
          
          ">
          <a href="/about/">About</a>
        </li>
      
    </ul>
  </nav>
 
  <nav class="social-menu collapsed">
    <h2 class="offscreen">Social Networks</h2>
    <ul class="social-list"></ul>
  </nav>
</header>

  <section class="main post-detail">
    <header class="post-header">
      <h1 class="post-title">elf文件格式和AndroidLinker加载.so的源码分析</h1>
      <p class="post-meta">@Ritchie Zhu · Mar 19, 2017 · 7 min read</p>
      
    </header>
     
     
<div class="post-toc" id="post-toc">
  
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#elf文件格式">elf文件格式</a></li>
    <li><a href="#android-linker加载so的源码分析">Android Linker加载.so的源码分析</a></li>
  </ul>
</nav>
  </div>
</div>

     
    <article class="post-content"><p>最近在学习android应用的加壳和混淆方法, 所以遇到了一些有关.so是如何加载到android中去的问题, 看了一些视频和文章, 所以想在此总结一下.</p>
<p>本文主要内容:</p>
<ul>
<li>elf的文件格式</li>
<li>分析linker的源码, 主要dlopen流程.</li>
</ul>
<h2 id="elf文件格式">elf文件格式</h2>
<p>本文只对elf文件格式进行简单的分析, 如果要进行深入的了解, 推荐<code>&lt;&lt;程序员的自我修养&gt;&gt;</code>中第3章.</p>
<p>/usr/includ/elf.h中定义了elf文件头结构和相关的常数.</p>
<p>分析elf文件时, 建议使用<code>010 editor</code>这款十六进制编辑软件, 运行elf模板后可以清晰的将文件格式显示出来, 大致的显示是(坑, 此处应该用图片的)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>				NAME                           Value            Start       Size		Color		Comment
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> file                                                 <span style="color:#ae81ff">0</span>h          <span style="color:#ae81ff">109</span>Ch
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">struct</span> elf_header                                       <span style="color:#ae81ff">0</span>h          <span style="color:#ae81ff">34</span>h
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">struct</span> program_header_table                             <span style="color:#ae81ff">34</span>h         <span style="color:#ae81ff">120</span>h
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">struct</span> section_header_table                             <span style="color:#ae81ff">1</span>B274h      <span style="color:#ae81ff">460</span>h
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">struct</span> dynamic_symbol_table                             <span style="color:#ae81ff">18</span>Ch        F10h
</span></span></code></pre></div><p>可以看到, 一个elf文件中包含一个header, 3个table, 我们一个一个的来分析一下.
首先分析<code>Elf header</code>, 它位于每一个elf文件开始的地方:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span>                                                            <span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span>
</span></span><span style="display:flex;"><span>{                                                                         {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> e_ident[EI_NIDENT]; <span style="color:#75715e">/* Magic number and other info */</span>     <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> e_ident[EI_NIDENT];
</span></span><span style="display:flex;"><span>	Elf32_Half    e_type;         <span style="color:#75715e">/* Object file type */</span>                  	Elf64_Half    e_type;     
</span></span><span style="display:flex;"><span>	Elf32_Half    e_machine;      <span style="color:#75715e">/* Architecture */</span>                      	Elf64_Half    e_machine;  
</span></span><span style="display:flex;"><span>	Elf32_Word    e_version;      <span style="color:#75715e">/* Object file version */</span>               	Elf64_Word    e_version;  
</span></span><span style="display:flex;"><span>	Elf32_Addr    e_entry;        <span style="color:#75715e">/* Entry point virtual address */</span>       	Elf64_Addr    e_entry;    
</span></span><span style="display:flex;"><span>	Elf32_Off e_phoff;        <span style="color:#75715e">/* Program header table file offset */</span>      	Elf64_Off e_phoff;        
</span></span><span style="display:flex;"><span>	Elf32_Off e_shoff;        <span style="color:#75715e">/* Section header table file offset */</span>      	Elf64_Off e_shoff;        
</span></span><span style="display:flex;"><span>	Elf32_Word    e_flags;        <span style="color:#75715e">/* Processor-specific flags */</span>          	Elf64_Word    e_flags;    
</span></span><span style="display:flex;"><span>	Elf32_Half    e_ehsize;       <span style="color:#75715e">/* ELF header size in bytes */</span>          	Elf64_Half    e_ehsize;   
</span></span><span style="display:flex;"><span>	Elf32_Half    e_phentsize;        <span style="color:#75715e">/* Program header table entry size */</span>	Elf64_Half    e_phentsize;
</span></span><span style="display:flex;"><span>	Elf32_Half    e_phnum;        <span style="color:#75715e">/* Program header table entry count */</span>  	Elf64_Half    e_phnum;    
</span></span><span style="display:flex;"><span>	Elf32_Half    e_shentsize;        <span style="color:#75715e">/* Section header table entry size */</span>	Elf64_Half    e_shentsize;
</span></span><span style="display:flex;"><span>	Elf32_Half    e_shnum;        <span style="color:#75715e">/* Section header table entry count */</span>  	Elf64_Half    e_shnum;    
</span></span><span style="display:flex;"><span>	Elf32_Half    e_shstrndx;     <span style="color:#75715e">/* Section header string table index */</span> 	Elf64_Half    e_shstrndx; 
</span></span><span style="display:flex;"><span>} Elf32_Ehdr;                                                              } Elf64_Ehdr;
</span></span></code></pre></div><p>可以看到, header中包含了magic number, 文件类型, 目标文件版本, 入口地址(如果为0, 说明此文件为可重定位文件), program header的开始地址(即为在so文件中的offset), section header的开始地址, 标志位, elf头本身的大小, program header和section header的size和数量, 最后是section header中string section在section中的下标.(用010 editor可以看到清楚的看到一个.so文件包含众多的program header 和 section header, 这两个段在做.so混淆时会经常分析)</p>
<p>现在分析<code>program header</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/* Program segment header.  */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span>														<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span>
</span></span><span style="display:flex;"><span>{                                                                   {
</span></span><span style="display:flex;"><span>	Elf32_Word    p_type;         <span style="color:#75715e">/* Segment type */</span>                	Elf64_Word    p_type;   
</span></span><span style="display:flex;"><span>	Elf32_Off p_offset;       <span style="color:#75715e">/* Segment file offset */</span>             	Elf64_Off p_offset;     
</span></span><span style="display:flex;"><span>	Elf32_Addr    p_vaddr;        <span style="color:#75715e">/* Segment virtual address */</span>     	Elf64_Addr    p_vaddr;  
</span></span><span style="display:flex;"><span>	Elf32_Addr    p_paddr;        <span style="color:#75715e">/* Segment physical address */</span>    	Elf64_Addr    p_paddr;  
</span></span><span style="display:flex;"><span>	Elf32_Word    p_filesz;       <span style="color:#75715e">/* Segment size in file */</span>        	Elf64_Word    p_filesz; 
</span></span><span style="display:flex;"><span>	Elf32_Word    p_memsz;        <span style="color:#75715e">/* Segment size in memory */</span>      	Elf64_Word    p_memsz;  
</span></span><span style="display:flex;"><span>	Elf32_Word    p_flags;        <span style="color:#75715e">/* Segment flags */</span>               	Elf64_Word    p_flags;  
</span></span><span style="display:flex;"><span>	Elf32_Word    p_align;        <span style="color:#75715e">/* Segment alignment */</span>           	Elf64_Word    p_align;  
</span></span><span style="display:flex;"><span>} Elf32_Phdr;														} Elf64_Phdr;
</span></span></code></pre></div><p>接下来分析<code>section header</code>, section相信了解过汇编的同学都非常熟悉了, 这个section header里面就存放了我们elf中各个段的信息.
看一下section header段描述符的结构:(64位的与32位的结构体大致相同, 只是把类型改为了Elf64的类型)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	Elf32_Word    sh_name;        <span style="color:#75715e">/* Section name (string tbl index) 段名*/</span>
</span></span><span style="display:flex;"><span>    Elf32_Word    sh_type;        <span style="color:#75715e">/* Section type 段类型*/</span>
</span></span><span style="display:flex;"><span>	Elf32_Word    sh_flags;       <span style="color:#75715e">/* Section flags 标志位*/</span>
</span></span><span style="display:flex;"><span>	Elf32_Addr    sh_addr;        <span style="color:#75715e">/* Section virtual addr at execution 段虚拟地址*/</span>
</span></span><span style="display:flex;"><span>	Elf32_Off sh_offset;          <span style="color:#75715e">/* Section file offset 段偏移*/</span>
</span></span><span style="display:flex;"><span>	Elf32_Word    sh_size;        <span style="color:#75715e">/* Section size in bytes 段的长度*/</span>
</span></span><span style="display:flex;"><span>	Elf32_Word    sh_link;        <span style="color:#75715e">/* Link to another section 段的链接信息*/</span>
</span></span><span style="display:flex;"><span>	Elf32_Word    sh_info;        <span style="color:#75715e">/* Additional section information 段链接的相关信息*/</span>
</span></span><span style="display:flex;"><span>	Elf32_Word    sh_addralign;   <span style="color:#75715e">/* Section alignment 段地址对齐*/</span>
</span></span><span style="display:flex;"><span>	Elf32_Word    sh_entsize;     <span style="color:#75715e">/* Entry size if section holds table 项的长度*/</span>
</span></span><span style="display:flex;"><span>} Elf32_Shdr;
</span></span></code></pre></div><p>最后分析动态符号表(<code>symbol table</code>):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  	Elf32_Word    st_name;        <span style="color:#75715e">/* Symbol name (string tbl index) */</span>
</span></span><span style="display:flex;"><span>	Elf32_Addr    st_value;       <span style="color:#75715e">/* Symbol value */</span>
</span></span><span style="display:flex;"><span>	Elf32_Word    st_size;        <span style="color:#75715e">/* Symbol size */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> st_info;        <span style="color:#75715e">/* Symbol type and binding */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> st_other;       <span style="color:#75715e">/* Symbol visibility */</span>
</span></span><span style="display:flex;"><span>	Elf32_Section st_shndx;       <span style="color:#75715e">/* Section index */</span>
</span></span><span style="display:flex;"><span>} Elf32_Sym;
</span></span></code></pre></div><p>包含的信息有符号名, 符号相对应的值, 符号大小, 符号类型和绑定信息, 符号所在的段.</p>
<h2 id="android-linker加载so的源码分析">Android Linker加载.so的源码分析</h2>
<p>Android中的本地文件.so是通过Linker加载到内存中去并且执行的.(本文分析的源码为Android4.4.4)
&mdash;- 推荐一款好用的源码阅读工具 source Insight</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>java<span style="color:#960050;background-color:#1e0010">层</span><span style="color:#f92672">:</span>  System.LoadLibrary(<span style="color:#e6db74">&#34;function&#34;</span>);
</span></span><span style="display:flex;"><span>native:			<span style="color:#f92672">---&gt;</span>  Dalvik<span style="color:#f92672">/</span>vm<span style="color:#f92672">/</span>native<span style="color:#f92672">/</span>java_lang_Runtime.cpp: Dalvik_java_lang_Runtime_nativeLoad 
</span></span><span style="display:flex;"><span>						<span style="color:#f92672">---&gt;</span>Dalvik<span style="color:#f92672">/</span>vm<span style="color:#f92672">/</span>Native.cpp: dvmLoadNativeCode(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> fileName, Object<span style="color:#f92672">*</span> ClassLoader, <span style="color:#66d9ef">char</span><span style="color:#f92672">**</span> reason)
</span></span><span style="display:flex;"><span>								<span style="color:#f92672">---&gt;</span>bionic<span style="color:#f92672">/</span>linker<span style="color:#f92672">/</span>dlfcn.c: dlopen(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> pathName, RTLD_LAZY)
</span></span><span style="display:flex;"><span>									 	<span style="color:#f92672">---&gt;</span>bionic<span style="color:#f92672">/</span>linker<span style="color:#f92672">/</span>linker.cpp: do_dlopen(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> name, <span style="color:#66d9ef">int</span> flags)
</span></span></code></pre></div><ol>
<li>核心函数为<code>do_dlopen</code>:</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>soinfo<span style="color:#f92672">*</span> <span style="color:#a6e22e">do_dlopen</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> name, <span style="color:#66d9ef">int</span> flags) {  <span style="color:#75715e">// 函数的参数为
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> ((flags <span style="color:#f92672">&amp;</span> <span style="color:#f92672">~</span>(RTLD_NOW<span style="color:#f92672">|</span>RTLD_LAZY<span style="color:#f92672">|</span>RTLD_LOCAL<span style="color:#f92672">|</span>RTLD_GLOBAL)) <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>		DL_ERR(<span style="color:#e6db74">&#34;invalid flags to dlopen: %x&#34;</span>, flags);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	set_soinfo_pool_protection(PROT_READ <span style="color:#f92672">|</span> PROT_WRITE);	<span style="color:#75715e">// 设置so信息池的访问权限为可读可写
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	soinfo<span style="color:#f92672">*</span> si <span style="color:#f92672">=</span> find_library(name);					<span style="color:#75715e">// 找到name函数, 装载so, 并返回指向.soinfo的指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (si <span style="color:#f92672">!=</span> NULL) {
</span></span><span style="display:flex;"><span>				      si<span style="color:#f92672">-&gt;</span>CallConstructors();			<span style="color:#75715e">// 初始化so库
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	}
</span></span><span style="display:flex;"><span>	set_soinfo_pool_protection(PROT_READ);				<span style="color:#75715e">// 设置so信息池的访问权限为只读
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">return</span> si;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ol start="2">
<li>查看<code>find_library</code>函数可以发现它调用了<code>find_library_internal</code>函数,</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> soinfo<span style="color:#f92672">*</span> <span style="color:#a6e22e">find_library</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> name) {
</span></span><span style="display:flex;"><span>	soinfo<span style="color:#f92672">*</span> si <span style="color:#f92672">=</span> find_library_internal(name);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (si <span style="color:#f92672">!=</span> NULL) {
</span></span><span style="display:flex;"><span>		si<span style="color:#f92672">-&gt;</span>ref_count<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> si;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>分析<code>find_library_internal</code>函数, 发现其主要调用了<code>load_library()</code>函数和 <code>soinfo_link_image()</code> 函数.
_</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> soinfo<span style="color:#f92672">*</span> <span style="color:#a6e22e">find_library_internal</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> name) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (name <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> somain;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	soinfo<span style="color:#f92672">*</span> si <span style="color:#f92672">=</span> find_loaded_library(name);			<span style="color:#75715e">// 判断.so是否完全加载, 如果加载: 返回有效的指针;如果没有加载, 返回null;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (si <span style="color:#f92672">!=</span> NULL) {								<span style="color:#75715e">// 如果已经加载，返回
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> (si<span style="color:#f92672">-&gt;</span>flags <span style="color:#f92672">&amp;</span> FLAG_LINKED) {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> si;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		DL_ERR(<span style="color:#e6db74">&#34;OOPS: recursive link to </span><span style="color:#ae81ff">\&#34;</span><span style="color:#e6db74">%s</span><span style="color:#ae81ff">\&#34;</span><span style="color:#e6db74">&#34;</span>, si<span style="color:#f92672">-&gt;</span>name);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	TRACE(<span style="color:#e6db74">&#34;[ &#39;%s&#39; has not been loaded yet.  Locating...]&#34;</span>, name);  <span style="color:#75715e">// 打印so还没有加载
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	si <span style="color:#f92672">=</span> load_library(name);		<span style="color:#75715e">// 加载.so
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (si <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// At this point we know that whatever is loaded @ base is a valid ELF
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// shared library whose segments are properly mapped in.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	TRACE(<span style="color:#e6db74">&#34;[ init_library base=0x%08x sz=0x%08x name=&#39;%s&#39; ]&#34;</span>,
</span></span><span style="display:flex;"><span>			si<span style="color:#f92672">-&gt;</span>base, si<span style="color:#f92672">-&gt;</span>size, si<span style="color:#f92672">-&gt;</span>name);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>soinfo_link_image(si)) {		<span style="color:#75715e">// 完成.so的重定位
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		munmap(<span style="color:#66d9ef">reinterpret_cast</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">void</span><span style="color:#f92672">*&gt;</span>(si<span style="color:#f92672">-&gt;</span>base), si<span style="color:#f92672">-&gt;</span>size);
</span></span><span style="display:flex;"><span>		soinfo_free(si);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> si;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>分析<code>load_library</code>函数, 会找到elf_read.<code>Load()</code>方法, 这个方法就是load</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> soinfo<span style="color:#f92672">*</span> <span style="color:#a6e22e">load_library</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> name) {
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Open the file.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">int</span> fd <span style="color:#f92672">=</span> open_library(name);						<span style="color:#75715e">// 打开文件, 获取fd
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (fd <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>		DL_ERR(<span style="color:#e6db74">&#34;library </span><span style="color:#ae81ff">\&#34;</span><span style="color:#e6db74">%s</span><span style="color:#ae81ff">\&#34;</span><span style="color:#e6db74"> not found&#34;</span>, name);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Read the ELF header and load the segments.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	ElfReader elf_reader(name, fd);						<span style="color:#75715e">// 初始化elfReader对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>elf_reader.Load()) {							<span style="color:#75715e">// 通过elfReader对象的Load()方法, 将so文件装载到内存
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> bname <span style="color:#f92672">=</span> strrchr(name, <span style="color:#e6db74">&#39;/&#39;</span>);
</span></span><span style="display:flex;"><span>	soinfo<span style="color:#f92672">*</span> si <span style="color:#f92672">=</span> soinfo_alloc(bname <span style="color:#f92672">?</span> bname <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">:</span> name);	<span style="color:#75715e">// 分配so_info结构, 并按照装载结果更新相应的成员变量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (si <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	si<span style="color:#f92672">-&gt;</span>base <span style="color:#f92672">=</span> elf_reader.load_start();
</span></span><span style="display:flex;"><span>	si<span style="color:#f92672">-&gt;</span>size <span style="color:#f92672">=</span> elf_reader.load_size();
</span></span><span style="display:flex;"><span>	si<span style="color:#f92672">-&gt;</span>load_bias <span style="color:#f92672">=</span> elf_reader.load_bias();
</span></span><span style="display:flex;"><span>	si<span style="color:#f92672">-&gt;</span>flags <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	si<span style="color:#f92672">-&gt;</span>entry <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	si<span style="color:#f92672">-&gt;</span>dynamic <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>	si<span style="color:#f92672">-&gt;</span>phnum <span style="color:#f92672">=</span> elf_reader.phdr_count();
</span></span><span style="display:flex;"><span>	si<span style="color:#f92672">-&gt;</span>phdr <span style="color:#f92672">=</span> elf_reader.loaded_phdr();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> si;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">这里放一个</span>ElfReader<span style="color:#960050;background-color:#1e0010">结构</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ElfReader</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>	ElfReader(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> name, <span style="color:#66d9ef">int</span> fd);
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">~</span>ElfReader();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">Load</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	size_t <span style="color:#a6e22e">phdr_count</span>() { <span style="color:#66d9ef">return</span> phdr_num_; }
</span></span><span style="display:flex;"><span>	Elf32_Addr <span style="color:#a6e22e">load_start</span>() { <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">reinterpret_cast</span><span style="color:#f92672">&lt;</span>Elf32_Addr<span style="color:#f92672">&gt;</span>(load_start_); }
</span></span><span style="display:flex;"><span>	Elf32_Addr <span style="color:#a6e22e">load_size</span>() { <span style="color:#66d9ef">return</span> load_size_; }
</span></span><span style="display:flex;"><span>	Elf32_Addr <span style="color:#a6e22e">load_bias</span>() { <span style="color:#66d9ef">return</span> load_bias_; }
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">const</span> Elf32_Phdr<span style="color:#f92672">*</span> <span style="color:#a6e22e">loaded_phdr</span>() { <span style="color:#66d9ef">return</span> loaded_phdr_; }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">bool</span> ReadElfHeader();
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">VerifyElfHeader</span>();
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">ReadProgramHeader</span>();
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">ReserveAddressSpace</span>();
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">LoadSegments</span>();
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">FindPhdr</span>();
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">CheckPhdr</span>(Elf32_Addr);	
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> name_;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> fd_;	
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	Elf32_Ehdr header_;
</span></span><span style="display:flex;"><span>	size_t phdr_num_;	
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> phdr_mmap_;
</span></span><span style="display:flex;"><span>	Elf32_Phdr<span style="color:#f92672">*</span> phdr_table_;
</span></span><span style="display:flex;"><span>	Elf32_Addr phdr_size_;	
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// First page of reserved address space.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> load_start_;
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Size in bytes of reserved address space.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	Elf32_Addr load_size_;
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Load bias.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	Elf32_Addr load_bias_;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Loaded phdr.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">const</span> Elf32_Phdr<span style="color:#f92672">*</span> loaded_phdr_;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>这里是<code>Load()</code>函数</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> ElfReader<span style="color:#f92672">::</span>Load() {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">ReadElfHeader</span>() <span style="color:#f92672">&amp;&amp;</span>					<span style="color:#75715e">// 读取
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		VerifyElfHeader() <span style="color:#f92672">&amp;&amp;</span>				<span style="color:#75715e">// 验证
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		ReadProgramHeader() <span style="color:#f92672">&amp;&amp;</span>				<span style="color:#75715e">// 读取Program header
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		ReserveAddressSpace() <span style="color:#f92672">&amp;&amp;</span>			<span style="color:#75715e">// 根据Program header计算so需要的内存size并分配相应的空间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		LoadSegments() <span style="color:#f92672">&amp;&amp;</span>					<span style="color:#75715e">// 将so按照segment为单位装载到内存
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		FindPhdr();						<span style="color:#75715e">// on 装载到内存的so中找到program header, 方便以后链接过程use
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><ul>
<li>首先是<code>ReadElfHeader</code>()函数, 发现其是直接调用<code>read</code>函数读取到header中的.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> ElfReader<span style="color:#f92672">::</span>ReadElfHeader() {
</span></span><span style="display:flex;"><span>	ssize_t rc <span style="color:#f92672">=</span> TEMP_FAILURE_RETRY(read(fd_, <span style="color:#f92672">&amp;</span>header_, <span style="color:#66d9ef">sizeof</span>(header_)));	<span style="color:#75715e">// use read() function 直接将elfheader读取到header中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#960050;background-color:#1e0010">```</span><span style="color:#75715e">//////////////////////////////
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>
<p>然后是<code>VerifyElfread</code>()函数, 对Elfheader进行验证识别: 是否为32位，大小端，类型和版本.</p>
</li>
<li>
<p>之后<code>ReadProgramHeader</code>()函数(加载program header table从elf文件到一个只读的私有匿名的mmap-ed block中):</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> ElfReader<span style="color:#f92672">::</span>ReadProgramHeader() {
</span></span><span style="display:flex;"><span>	phdr_num_ <span style="color:#f92672">=</span> header_.e_phnum;										
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//  将program header on内存中中单独映射一份, use于解析时临时use, on so装载到内存后, 便会释放这块内存, 转而使use装载后的so中的program header
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Like the kernel, we only accept program header tables that
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// are smaller than 64KiB.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (phdr_num_ <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">||</span> phdr_num_ <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">65536</span><span style="color:#f92672">/</span><span style="color:#66d9ef">sizeof</span>(Elf32_Phdr)) {
</span></span><span style="display:flex;"><span>		DL_ERR(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\&#34;</span><span style="color:#e6db74">%s</span><span style="color:#ae81ff">\&#34;</span><span style="color:#e6db74"> has invalid e_phnum: %d&#34;</span>, name_, phdr_num_);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	Elf32_Addr page_min <span style="color:#f92672">=</span> PAGE_START(header_.e_phoff);
</span></span><span style="display:flex;"><span>	Elf32_Addr page_max <span style="color:#f92672">=</span> PAGE_END(header_.e_phoff <span style="color:#f92672">+</span> (phdr_num_ <span style="color:#f92672">*</span> <span style="color:#66d9ef">sizeof</span>(Elf32_Phdr)));
</span></span><span style="display:flex;"><span>	Elf32_Addr page_offset <span style="color:#f92672">=</span> PAGE_OFFSET(header_.e_phoff);	
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	phdr_size_ <span style="color:#f92672">=</span> page_max <span style="color:#f92672">-</span> page_min;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> mmap_result <span style="color:#f92672">=</span> mmap(NULL, phdr_size_, PROT_READ, MAP_PRIVATE, fd_, page_min);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (mmap_result <span style="color:#f92672">==</span> MAP_FAILED) {
</span></span><span style="display:flex;"><span>		DL_ERR(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\&#34;</span><span style="color:#e6db74">%s</span><span style="color:#ae81ff">\&#34;</span><span style="color:#e6db74"> phdr mmap failed: %s&#34;</span>, name_, strerror(errno));
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	phdr_mmap_ <span style="color:#f92672">=</span> mmap_result;
</span></span><span style="display:flex;"><span>	phdr_table_ <span style="color:#f92672">=</span> <span style="color:#66d9ef">reinterpret_cast</span><span style="color:#f92672">&lt;</span>Elf32_Phdr<span style="color:#f92672">*&gt;</span>(<span style="color:#66d9ef">reinterpret_cast</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">char</span><span style="color:#f92672">*&gt;</span>(mmap_result) <span style="color:#f92672">+</span> page_offset);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li><code>ReverveAddressSpace</code>()函数(准备虚拟内存足够的大来存放Program header中的<code>Load</code>段(两个Load段～～) 通过<code>mmap with PROT_NONE</code> 实现</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> ElfReader<span style="color:#f92672">::</span>ReserveAddressSpace() {
</span></span><span style="display:flex;"><span>	Elf32_Addr min_vaddr;
</span></span><span style="display:flex;"><span>	load_size_ <span style="color:#f92672">=</span> phdr_table_get_load_size(phdr_table_, phdr_num_, <span style="color:#f92672">&amp;</span>min_vaddr);	<span style="color:#75715e">// 获取so on 内存中需要的空间load_size
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (load_size_ <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>	      DL_ERR(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\&#34;</span><span style="color:#e6db74">%s</span><span style="color:#ae81ff">\&#34;</span><span style="color:#e6db74"> has no loadable segments&#34;</span>, name_);
</span></span><span style="display:flex;"><span>		      <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">uint8_t</span><span style="color:#f92672">*</span> addr <span style="color:#f92672">=</span> <span style="color:#66d9ef">reinterpret_cast</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">uint8_t</span><span style="color:#f92672">*&gt;</span>(min_vaddr);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> start <span style="color:#f92672">=</span> mmap(addr, load_size_, PROT_NONE, mmap_flags, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>);			<span style="color:#75715e">// use mmap匿名映射, 预留出相应的空间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">int</span> mmap_flags <span style="color:#f92672">=</span> MAP_PRIVATE <span style="color:#f92672">|</span> MAP_ANONYMOUS;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (start <span style="color:#f92672">==</span> MAP_FAILED) {
</span></span><span style="display:flex;"><span>		DL_ERR(<span style="color:#e6db74">&#34;couldn&#39;t reserve %d bytes of address space for </span><span style="color:#ae81ff">\&#34;</span><span style="color:#e6db74">%s</span><span style="color:#ae81ff">\&#34;</span><span style="color:#e6db74">&#34;</span>, load_size_, name_);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	load_start_ <span style="color:#f92672">=</span> start;
</span></span><span style="display:flex;"><span>	load_bias_ <span style="color:#f92672">=</span> <span style="color:#66d9ef">reinterpret_cast</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">uint8_t</span><span style="color:#f92672">*&gt;</span>(start) <span style="color:#f92672">-</span> addr;				<span style="color:#75715e">// so可以指定加载的基址, 但是so指定的加载基址可能不是页对齐的, 这种情况
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">return</span> true;															<span style="color:#75715e">// 会导致实际映射地址和指定的加载地址有一个偏差, 这个偏差便是load_bias
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><ul>
<li><code>LoadSegments</code>()函数(在进程地址空间中加载所有可加载的段(假设你已经预留了空间为这个library)):</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> ElfReader<span style="color:#f92672">::</span>LoadSegments() {	
</span></span><span style="display:flex;"><span>  	<span style="color:#66d9ef">for</span> (size_t i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> phdr_num_; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">const</span> Elf32_Phdr<span style="color:#f92672">*</span> phdr <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>phdr_table_[i];	<span style="color:#75715e">// 遍历program header table
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (phdr<span style="color:#f92672">-&gt;</span>p_type <span style="color:#f92672">!=</span> PT_LOAD) {			<span style="color:#75715e">// 加载所有p_type == PT_LOAD的段
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#960050;background-color:#1e0010">```</span> <span style="color:#960050;background-color:#1e0010">之后就是一些设置段地址，段偏移</span>, <span style="color:#960050;background-color:#1e0010">之后</span>mmap<span style="color:#960050;background-color:#1e0010">的一些操作</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li><code>FindPhdr</code>()(返回program header table加载到内存中的地址, 因为之后还要执行.so的重定位).
现在回到我们<code>find_library_internal</code>()这里，在执行完load_library()之后, 还有一个重要的函数为 <code>soinfo_link_image</code>(soinfo* si):</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">这个函数会完成</span>.so<span style="color:#960050;background-color:#1e0010">的动态链接，其中包含我们加载的</span>.so<span style="color:#960050;background-color:#1e0010">库的重定位过程</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span> <span style="color:#ae81ff">1.</span> <span style="color:#960050;background-color:#1e0010">定位动态</span>section,<span style="color:#960050;background-color:#1e0010">将动态</span>section<span style="color:#960050;background-color:#1e0010">的虚拟地址和项数和读写权限存在</span>dynamic, dynamic_count, dynamic_flags<span style="color:#960050;background-color:#1e0010">中</span>.
</span></span><span style="display:flex;"><span>	size_t dynamic_count;
</span></span><span style="display:flex;"><span>	Elf32_Word dynamic_flags;
</span></span><span style="display:flex;"><span>	phdr_table_get_dynamic_section(phdr, phnum, base, <span style="color:#f92672">&amp;</span>si<span style="color:#f92672">-&gt;</span>dynamic,		<span style="color:#75715e">// 定位dynamic section
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	                                   <span style="color:#f92672">&amp;</span>dynamic_count, <span style="color:#f92672">&amp;</span>dynamic_flags);		<span style="color:#75715e">// 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span> <span style="color:#ae81ff">2.</span> <span style="color:#960050;background-color:#1e0010">解析</span>Dynamic section
</span></span><span style="display:flex;"><span> <span style="color:#ae81ff">3.</span> <span style="color:#960050;background-color:#1e0010">调用</span>find_library, <span style="color:#960050;background-color:#1e0010">返回所有依赖的</span>.so<span style="color:#960050;background-color:#1e0010">的</span>soinfo<span style="color:#960050;background-color:#1e0010">指针并存放在数组中</span>.
</span></span><span style="display:flex;"><span> <span style="color:#ae81ff">4.</span> <span style="color:#960050;background-color:#1e0010">重定位</span>(<span style="color:#960050;background-color:#1e0010">处理</span>plt_rel(<span style="color:#960050;background-color:#1e0010">延迟绑定</span>)<span style="color:#960050;background-color:#1e0010">和</span>rel)<span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span> 	<span style="color:#960050;background-color:#1e0010">可以看到</span>, <span style="color:#960050;background-color:#1e0010">处理两个重定位表的函数都是</span>soinfo_relocate<span style="color:#960050;background-color:#1e0010">函数</span>.
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (si<span style="color:#f92672">-&gt;</span>plt_rel <span style="color:#f92672">!=</span> NULL) {
</span></span><span style="display:flex;"><span>		DEBUG(<span style="color:#e6db74">&#34;[ relocating %s plt ]&#34;</span>, si<span style="color:#f92672">-&gt;</span>name );
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (soinfo_relocate(si, si<span style="color:#f92672">-&gt;</span>plt_rel, si<span style="color:#f92672">-&gt;</span>plt_rel_count, needed)) {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (si<span style="color:#f92672">-&gt;</span>rel <span style="color:#f92672">!=</span> NULL) {
</span></span><span style="display:flex;"><span>		DEBUG(<span style="color:#e6db74">&#34;[ relocating %s ]&#34;</span>, si<span style="color:#f92672">-&gt;</span>name );
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (soinfo_relocate(si, si<span style="color:#f92672">-&gt;</span>rel, si<span style="color:#f92672">-&gt;</span>rel_count, needed)) {		 
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}		
</span></span></code></pre></div><p>现在分析soinfo_relocate函数</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"></code></pre></div></article>
    <footer class="post-footer">
      
      <ul class="post-tags">
        
          <li><a href="/tags/%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F"><span class="tag">文件格式</span></a></li>
        
          <li><a href="/tags/android%E6%BA%90%E7%A0%81"><span class="tag">Android源码</span></a></li>
        
      </ul>
      
      
      
<div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">2017-03-19</span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">许可协议</span>
    <span class="item-content">原创文章，如需转载请注明文章作者和出处。谢谢！</span>
  </p>
</div>
    </footer>
    
      
    
  </section>
  
  

  
  
  
<footer class="site-footer">
  <p>© 2017-2022 L0phTg&#39;s Blog</p>
  <p>Powered by <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> with theme <a href="https://github.com/laozhu/hugo-nuo" target="_blank" rel="noopener">Nuo</a>.</p>
  
</footer>


<script src="https://cdn.jsdelivr.net/npm/smooth-scroll@15.0.0/dist/smooth-scroll.min.js"></script>



<script async src="https://cdn.jsdelivr.net/npm/video.js@7.3.0/dist/video.min.js"></script>




<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$','$'], ['\\(','\\)']],
      displayMath: [['$$','$$'], ['\\[','\\]']],
      processEscapes: true,
      processEnvironments: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
      TeX: { equationNumbers: { autoNumber: "AMS" },
      extensions: ["AMSmath.js", "AMSsymbols.js"] }
    },
  });
</script>
<script type="text/x-mathjax-config">
  // Fix <code> tags after MathJax finishes running. This is a
  // hack to overcome a shortcoming of Markdown. Discussion at
  // https://github.com/mojombo/jekyll/issues/199
  MathJax.Hub.Queue(() => {
    MathJax.Hub.getAllJax().map(v => v.SourceElement().parentNode.className += ' has-jax');
  });
</script>



<script src="/scripts/index.min.js"></script>

<script>
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('\/service-worker.js').then(function() {
      console.log('[ServiceWorker] Registered');
    });
  }
</script>








    
  </body>
</html>
